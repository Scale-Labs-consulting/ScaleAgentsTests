import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

export async function POST(request: NextRequest) {
  console.log('üöÄ API ROUTE CALLED - /api/sales-analyst/analyze')
  
  try {
    const { transcription, salesCallId, userId, originalFileName } = await request.json()
    
    console.log('üìÅ Received originalFileName:', originalFileName)
    console.log('üìÅ Type of originalFileName:', typeof originalFileName)
    
    if (!transcription) {
      return NextResponse.json(
        { error: 'Transcription is required' },
        { status: 400 }
      )
    }

    console.log('üìù Analyzing transcription with GPT-4...')
    console.log('üìä Transcription length:', transcription.length, 'characters')

    // Check OpenAI API key
    if (!process.env.OPENAI_KEY) {
      console.error('‚ùå OpenAI API key is missing')
      return NextResponse.json(
        { error: 'OpenAI API key not configured' },
        { status: 500 }
      )
    }

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Function to estimate token count (rough approximation: 1 token ‚âà 4 characters)
    function estimateTokens(text: string): number {
      return Math.ceil(text.length / 4)
    }

    // Function to split transcription into chunks for GPT-4o-mini (128K context)
    function splitTranscriptionIntoChunks(transcription: string, maxCharsPerChunk: number = 20000): string[] {
      if (transcription.length <= maxCharsPerChunk) {
        return [transcription]
      }

      const chunks: string[] = []
      let currentChunk = ''
      const sentences = transcription.split(/(?<=[.!?])\s+/)
      
      for (const sentence of sentences) {
        if ((currentChunk + sentence).length <= maxCharsPerChunk) {
          currentChunk += sentence + ' '
        } else {
          if (currentChunk.trim()) {
            chunks.push(currentChunk.trim())
          }
          currentChunk = sentence + ' '
        }
      }
      
      if (currentChunk.trim()) {
        chunks.push(currentChunk.trim())
      }
      
      console.log(`üì¶ Split transcription into ${chunks.length} chunks`)
      return chunks
    }

    // Function to analyze chunks and combine results
    async function analyzeInChunks(
      transcription: string, 
      promptTemplate: string, 
      systemMessage: string,
      analysisType: string
    ): Promise<string> {
      const chunks = splitTranscriptionIntoChunks(transcription)
      
      if (chunks.length === 1) {
        // Single chunk - direct analysis
        console.log(`üìã Analyzing ${analysisType} with single chunk...`)
                 return await makeGPTCall(
           promptTemplate.replace('${TRANSCRIPTION}', chunks[0]),
           systemMessage
         )
      }
      
      // Multiple chunks - analyze each and combine
      console.log(`üìã Analyzing ${analysisType} with ${chunks.length} chunks...`)
      
      const chunkResults: string[] = []
      
      for (let i = 0; i < chunks.length; i++) {
        console.log(`üì¶ Processing chunk ${i + 1}/${chunks.length} for ${analysisType}...`)
        
        const chunkPrompt = promptTemplate.replace('${TRANSCRIPTION}', chunks[i])
                 const chunkResult = await makeGPTCall(
           chunkPrompt,
           systemMessage
         )
        
        chunkResults.push(chunkResult)
      }
      
      // Combine chunk results
      console.log(`üîó Combining ${chunks.length} chunk results for ${analysisType}...`)
      const combinedPrompt = `Analisa os seguintes resultados de an√°lise de diferentes partes da mesma call de vendas e cria uma an√°lise final consolidada:

${chunkResults.map((result, index) => `PARTE ${index + 1}:\n${result}`).join('\n\n')}

Cria uma an√°lise final que combine todos estes resultados de forma coerente e abrangente.`

             return await makeGPTCall(
         combinedPrompt,
         `√âs um analista especializado em consolida√ß√£o de an√°lises de calls de vendas. A tua fun√ß√£o √© combinar m√∫ltiplas an√°lises parciais numa an√°lise final completa e coerente.`
       )
    }

    // Make multiple focused API calls for comprehensive analysis
    console.log('üîÑ Starting multi-step analysis...')
    
         // Step 1: Call Type Classification
     console.log('üìã Step 1: Analyzing call type...')
     const callTypePrompt = `Analisa a seguinte transcri√ß√£o de conversa e classifica-a numa das seguintes categorias:

 Discovery Call: Uma primeira conversa onde o vendedor procura entender as necessidades, desafios e objetivos do potencial cliente. Caracter√≠sticas t√≠picas incluem: apresenta√ß√µes iniciais, perguntas sobre a empresa/neg√≥cio do cliente, identifica√ß√£o de problemas, explora√ß√£o da situa√ß√£o atual, e quest√µes sobre or√ßamento, autoridade de decis√£o, cronograma ou necessidades espec√≠ficas.

 Follow-up Call: Uma conversa de acompanhamento ap√≥s contato inicial. Caracter√≠sticas t√≠picas incluem: refer√™ncias a conversas anteriores, atualiza√ß√µes sobre progressos, respostas a quest√µes pendentes, apresenta√ß√£o de solu√ß√µes personalizadas com base na discovery call, e discuss√µes sobre pr√≥ximos passos concretos.

 Q&A Call: Uma conversa focada principalmente em responder perguntas espec√≠ficas do cliente sobre o produto/servi√ßo. Caracter√≠sticas t√≠picas incluem: muitas perguntas t√©cnicas ou de implementa√ß√£o, esclarecimentos sobre funcionalidades espec√≠ficas, e poucos elementos de descoberta ou follow-up.

 Analisa a transcri√ß√£o completa para fazer tua determina√ß√£o, pois o tipo de call pode ser confirmado ao longo de toda a conversa.

 Ap√≥s analisar, responde APENAS com o nome exato da categoria: "Discovery Call", "Follow-up Call", ou "Q&A Call". N√£o incluas explica√ß√µes ou texto adicional.

 TRANSCRI√á√ÉO:
 ${transcription}`

    const callTypeResult = await analyzeInChunks(
      transcription,
      callTypePrompt,
      '√âs um analista especializado em classifica√ß√£o de chamadas de vendas.',
      'call type'
    )

    // Step 2: Speaker Identification and Quantitative Analysis
    console.log('üìä Step 2: Identifying speakers and analyzing conversation balance...')
    const quantitativePrompt = `Por favor, analise a transcri√ß√£o da call a seguir e identifique os seguintes pontos:

IDENTIFICA√á√ÉO DOS FALANTES
- Analisa a transcri√ß√£o para identificar quem √© o COMERCIAL (vendedor) e quem √© o CLIENTE.
- Procura por indicadores como:
  * Quem faz perguntas sobre necessidades, problemas, or√ßamento
  * Quem apresenta solu√ß√µes, produtos ou servi√ßos
  * Quem fala sobre a pr√≥pria empresa vs. quem fala sobre a empresa do outro
  * Quem conduz a reuni√£o e quem responde √†s perguntas
  * Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos
- Identifica claramente: "O COMERCIAL √© [nome/identifica√ß√£o]" e "O CLIENTE √© [nome/identifica√ß√£o]"

DISTRIBUI√á√ÉO DA CONVERSA
- Calcule a percentagem de fala de cada parte (comercial e cliente), considerando a quantidade de palavras ou tempo falado.
- Apresente os resultados com a percentagem exata de fala do comercial e do cliente.

TEMPO DE RESPOSTA DO COMERCIAL
- Me√ßa o tempo m√©dio de resposta do comercial a cada interven√ß√£o do cliente.
- Indique esses tempos em minutos e segundos.

PROPOR√á√ïES IDEAIS DE FALA
Compare as propor√ß√µes de fala reais com as propor√ß√µes ideais para cada tipo de call:
- Discovery Call: Cliente 60% / Comercial 40%
- Follow-Up: Cliente 50% / Comercial 50%
- Q&A: Cliente 50% / Comercial 50%

FEEDBACK SOBRE O EQUIL√çBRIO DA CONVERSA
- Compare as propor√ß√µes reais de fala com as propor√ß√µes ideais.
- Forne√ßa feedback sobre como melhorar o equil√≠brio da conversa e o engajamento entre o comercial e o cliente.

Transcri√ß√£o da Chamada:
${transcription}

Instru√ß√µes cr√≠ticas:
1. N√ÉO uses markdown, s√≠mbolos extras ou emojis.
2. Escreve sempre em portugu√™s de Lisboa.
3. Usa formata√ß√£o simples com t√≠tulos em MAI√öSCULAS e listas com h√≠fens.
4. Os valores devem ser apresentados de forma clara e direta.
5. Da-me so o resultado final, n√£o precisas de dar comentarios adicionais
6. √â CR√çTICO identificar corretamente quem √© o comercial vs. cliente`

    const quantitativeResult = await analyzeInChunks(
      transcription,
      quantitativePrompt,
      '√âs um analista especializado em an√°lise quantitativa de conversas de vendas.',
      'quantitative analysis'
    )

    // Step 3: Strong Points Analysis
    console.log('üí™ Step 3: Analyzing strong points...')
    const strengthsPrompt = `Analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e identifica os pontos fortes do vendedor ao longo da call.

IMPORTANTE: Primeiro identifica quem √© o vendedor na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do vendedor identificado.

TRANSCRI√á√ÉO:
${transcription}

Estrutura o output como uma lista de par√°grafos separados, cada um come√ßando com um bullet point (‚Ä¢), com coment√°rios objectivos e claros sobre os momentos mais positivos do vendedor na reuni√£o.

IMPORTANTE: Cada ponto deve estar num par√°grafo separado, come√ßando com "‚Ä¢ " e terminando com uma quebra de linha.

Indica sempre os timestamps dos momentos para contextualizar as falas.

Observa o desempenho do vendedor ao longo destas fases:
- In√≠cio da reuni√£o (apresenta√ß√£o inicial e rapport)
- Perguntas feitas (inten√ß√£o, impacto, relev√¢ncia)
- Apresenta√ß√£o da solu√ß√£o/proposta (clareza, personaliza√ß√£o, diferencia√ß√£o)
- Gest√£o de obje√ß√µes (respostas bem estruturadas, confian√ßa, seguran√ßa)
- Fecho da reuni√£o (pr√≥ximos passos, compromisso)

Usa frases como:
- "No in√≠cio, mostrou interesse genu√≠no ao perguntar sobre..."
- "A pergunta sobre X foi crucial porque..."
- "No meio da call, teve o seu momento mais forte quando..."
- "Transmitiu seguran√ßa quando disse..."

D√° especial aten√ß√£o a falas que demonstrem empatia, autoridade, personaliza√ß√£o e vis√£o estrat√©gica. Sempre que fizer sentido, inclui uma cita√ß√£o direta da transcri√ß√£o para ilustrar o ponto.

Mant√©m a linguagem simples, directa e sem floreados.
N√£o uses t√≠tulos como "Pontos Fortes" ou "Conclus√£o". Apenas a lista, como se fosse um feedback direto.

FORMATO OBRIGAT√ìRIO:
‚Ä¢ [Primeiro ponto forte] [quebra de linha]
‚Ä¢ [Segundo ponto forte] [quebra de linha]
‚Ä¢ [Terceiro ponto forte] [quebra de linha]
etc.

Usa sempre Timestamp das frases que utilizaste para contextualizar.

Indica em que momento esteve mais forte, e porque.

Idioma: portugu√™s de Portugal (Lisboa), com uso de pret√©rito perfeito simples e sem ger√∫ndios.`

    const strengthsResult = await analyzeInChunks(
      transcription,
      strengthsPrompt,
      '√âs um analista especializado em identificar pontos fortes em chamadas de vendas.',
      'strengths analysis'
    )

    // Step 4: Weak Points Analysis
    console.log('‚ö†Ô∏è Step 4: Analyzing weak points...')
    const weaknessesPrompt = `Antes de tudo verifica a an√°lise dos pontos fortes que te vou dar, para que n√£o ha descrepancias de informa√ß√£o: ${strengthsResult}

Agora analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e identifica os pontos fracos do vendedor ao longo da call.

IMPORTANTE: Primeiro identifica quem √© o vendedor na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do vendedor identificado.

TRANSCRI√á√ÉO:
${transcription}

Depois de analisares, estrutura o output como uma lista de par√°grafos separados, cada um come√ßando com um bullet point (‚Ä¢), com coment√°rios objectivos e claros sobre os momentos mais fr√°geis do vendedor na reuni√£o.

IMPORTANTE: Cada ponto deve estar num par√°grafo separado, come√ßando com "‚Ä¢ " e terminando com uma quebra de linha.

Indica sempre a timestamp das falas para contextualizar.

Observa o desempenho do vendedor ao longo destas fases:
- In√≠cio da reuni√£o (apresenta√ß√£o inicial e rapport)
- Perguntas feitas (inten√ß√£o, impacto, profundidade)
- Apresenta√ß√£o da solu√ß√£o/proposta (clareza, excesso de detalhe t√©cnico, falta de alinhamento)
- Gest√£o de obje√ß√µes (respostas gen√©ricas, falta de escuta ativa, hesita√ß√£o)
- Fecho da reuni√£o (pr√≥ximos passos pouco claros, falta de urg√™ncia ou follow-up forte)

Usa frases como:
- "No in√≠cio, poderia ter evitado..."
- "A pergunta sobre X poderia ter sido mais espec√≠fica porque..."
- "Neste momento, deixou passar uma oportunidade de aprofundar..."
- "Faltou clareza quando disse..."
- "No fecho, n√£o criou um verdadeiro sentido de urg√™ncia porque..."

D√° especial aten√ß√£o a momentos em que:
- N√£o aproveitou oportunidades para aprofundar a dor da lead
- Falou demasiado de funcionalidades em vez de benef√≠cios concretos
- Soou gen√©rico ou pouco consultivo
- Evitou lidar diretamente com uma preocupa√ß√£o do cliente

Sempre que fizer sentido, inclui uma cita√ß√£o direta da transcri√ß√£o para ilustrar o ponto.

FORMATO OBRIGAT√ìRIO:
‚Ä¢ [Primeiro ponto fraco] [quebra de linha]
‚Ä¢ [Segundo ponto fraco] [quebra de linha]
‚Ä¢ [Terceiro ponto fraco] [quebra de linha]
etc.

Usa sempre timestamp das frases que utilizaste para contextualizar.

Indica em que momento teve o ponto mais fraco da call e justifica.

Idioma: portugu√™s de Portugal (Lisboa), com uso de pret√©rito perfeito simples e sem ger√∫ndios.`

    const weaknessesResult = await analyzeInChunks(
      transcription,
      weaknessesPrompt,
      '√âs um analista especializado em identificar pontos fracos em chamadas de vendas.',
      'weaknesses analysis'
    )

    // Step 5: Scoring Analysis
    console.log('‚≠ê Step 5: Analyzing scoring...')
    const scoringPrompt = `Analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e fornece uma pontua√ß√£o detalhada do vendedor.

IMPORTANTE: Primeiro identifica quem √© o vendedor na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do vendedor identificado.

TRANSCRI√á√ÉO:
${transcription}

Avalia o vendedor em cada categoria usando uma escala de 1 a 5, onde:
1 = Muito fraco
2 = Fraco  
3 = M√©dio
4 = Bom
5 = Excelente

Fornece uma pontua√ß√£o para cada categoria e uma pontua√ß√£o total:

Clareza e Flu√™ncia da Fala: [pontua√ß√£o]/5
Tom e Controlo: [pontua√ß√£o]/5
Envolvimento Conversacional: [pontua√ß√£o]/5
Efetividade na Descoberta de Necessidades: [pontua√ß√£o]/5
Entrega de Valor e Ajuste da Solu√ß√£o: [pontua√ß√£o]/5
Habilidades de Lidar com Obje√ß√µes: [pontua√ß√£o]/5
Estrutura e Controle da Reuni√£o: [pontua√ß√£o]/5
Fechamento e Pr√≥ximos Passos: [pontua√ß√£o]/5

Total: [soma de todas as pontua√ß√µes]/40

Exemplo de resposta:
Clareza e Flu√™ncia da Fala: 4/5
Tom e Controlo: 3/5
Envolvimento Conversacional: 4/5
Efetividade na Descoberta de Necessidades: 5/5
Entrega de Valor e Ajuste da Solu√ß√£o: 4/5
Habilidades de Lidar com Obje√ß√µes: 3/5
Estrutura e Controle da Reuni√£o: 4/5
Fechamento e Pr√≥ximos Passos: 4/5

Total: 31/40

Usa portugu√™s de Portugal (Lisboa).
Evita ger√∫ndios, usa pret√©rito perfeito simples.
N√£o uses emojis ou formata√ß√£o especial.`

    const scoringResult = await analyzeInChunks(
      transcription,
      scoringPrompt,
      '√âs um analista especializado em pontua√ß√£o de performance de vendas.',
      'scoring analysis'
    )

    // Step 6: Strong and Weak Moments by Phase
    console.log('üìà Step 6: Analyzing moments by phase...')
    const momentsPrompt = `Resumo Momentos Fortes e Fracos do comercial:

√âs um assistente especializado em an√°lise de calls de vendas. A tua √∫nica fun√ß√£o √© analisar a transcri√ß√£o da call e identificar os momentos de maior e menor desempenho do comercial.

Quando eu te fornecer uma transcri√ß√£o completa de uma call de vendas, a tua resposta deve ser objetiva e fornecer um feedback generalizado sobre tr√™s momentos-chave: in√≠cio, meio e fim da reuni√£o. N√£o precisas de analisar cada segundo ou minuto da conversa, apenas destacar os pontos essenciais do desempenho do comercial nos seguintes aspetos:

In√≠cio da Call:
- Apresenta√ß√£o inicial: Como foi a introdu√ß√£o? O comercial gerou rapport com o lead?
- Perguntas: O comercial fez boas perguntas para entender as necessidades do lead?

Meio da Call:
- Apresenta√ß√£o do servi√ßo/proposta: O comercial explicou bem a solu√ß√£o? Conseguiu manter o interesse?
- Lidar com obje√ß√µes: Como o comercial geriu d√∫vidas e preocupa√ß√µes do lead?

Fim da Call:
- Fecho e/ou pr√≥ximos passos: O comercial conduziu bem o encerramento? O lead ficou com clareza sobre os pr√≥ximos passos?

Estrutura da Resposta:

Momentos Fortes do Comercial:
- In√≠cio: [Destaca um ponto forte do in√≠cio da call]
- Meio: [Destaca um ponto forte do meio da call]
- Fim: [Destaca um ponto forte do final da call]

Momentos Fracos do Comercial:
- In√≠cio: [Identifica um ponto fraco do in√≠cio da call]
- Meio: [Identifica um ponto fraco do meio da call]
- Fim: [Identifica um ponto fraco do final da call]

Regras Importantes:
- A tua resposta deve ser clara e objetiva ‚Äì apenas o essencial.
- N√£o uses emojis, n√∫meros, markdowns ou qualquer tipo de formata√ß√£o especial. Apenas texto normal.
- Usa apenas texto limpo, pois o resultado ser√° inserido diretamente no Google Sheets.
- Mant√©m o foco na qualidade do discurso, t√©cnicas de venda, persuas√£o e fechamento.
- Se n√£o houver momentos fortes ou fracos evidentes em alguma parte (in√≠cio, meio ou fim), diz "N√£o foi identificado".

Todas as tuas respostas devem ser exclusivamente em portugu√™s de Portugal (especificamente de Lisboa), respeitando as seguintes regras:

1. Tratamento: Utiliza "tu" em vez de "voc√™" para tratamento informal e "o senhor/a senhora" para tratamento formal.
2. Pronomes e Conjuga√ß√µes: Utiliza "tu fazes" em vez de "voc√™ faz", utiliza os pronomes "te/ti/contigo" em vez de formas com "voc√™", utiliza a 2¬™ pessoa do singular nas conjuga√ß√µes verbais: "tu est√°s", "tu vais", etc.
3. Evita ger√∫ndios: Utiliza "estou a fazer" em vez de "estou fazendo", utiliza "estamos a analisar" em vez de "estamos analisando", substitui todas as constru√ß√µes com ger√∫ndio pela estrutura "a + infinitivo".
4. Coloca√ß√£o dos pronomes cl√≠ticos: Prefere a √™nclise na maioria dos contextos ("Disse-me" em vez de "Me disse").
5. Preserva os sons e sotaque lisboeta, que tende a reduzir as vogais √°tonas.
6. Utiliza sempre o pret√©rito perfeito simples em vez do composto em situa√ß√µes de a√ß√µes conclu√≠das ("Eu comi" em vez de "Eu tenho comido").

√â ABSOLUTAMENTE ESSENCIAL que todas as respostas sigam estas regras, sem exce√ß√£o. Em caso de d√∫vida, opta sempre pela forma utilizada em Portugal, especificamente em Lisboa.

TRANSCRI√á√ÉO:
${transcription}`

    const momentsResult = await analyzeInChunks(
      transcription,
      momentsPrompt,
      '√âs um analista especializado em an√°lise temporal de chamadas de vendas.',
      'moments analysis'
    )

    // Step 7: Call Summary Analysis (Resumo da Call)
    console.log('üìã Step 7: Analyzing call summary...')
    const callSummaryPrompt = `Analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e cria um resumo detalhado dos momentos fortes e fracos do COMERCIAL (vendedor) ao longo da call.

IMPORTANTE: Primeiro identifica quem √© o COMERCIAL na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do COMERCIAL identificado.

TRANSCRI√á√ÉO:
${transcription}

Cria um resumo estruturado com os seguintes pontos:

Momentos Fortes do Comercial:
- In√≠cio: [Analisa como o comercial se apresentou, criou rapport, e iniciou a conversa]
- Meio: [Analisa como o comercial apresentou a proposta, lidou com obje√ß√µes, e manteve o interesse]
- Fim: [Analisa como o comercial fechou a reuni√£o, definiu pr√≥ximos passos, e criou compromisso]

Momentos Fracos do Comercial:
- In√≠cio: [Identifica falhas na apresenta√ß√£o inicial, cria√ß√£o de rapport, ou organiza√ß√£o]
- Meio: [Identifica problemas na apresenta√ß√£o da proposta, gest√£o de obje√ß√µes, ou comunica√ß√£o]
- Fim: [Identifica falhas no fechamento, defini√ß√£o de pr√≥ximos passos, ou clareza]

Regras importantes:
- Usa sempre timestamps das falas para contextualizar
- Inclui cita√ß√µes diretas da transcri√ß√£o quando relevante
- Foca apenas no desempenho do COMERCIAL
- Seja espec√≠fico e objetivo
- Usa portugu√™s de Portugal (Lisboa)
- Evita ger√∫ndios, usa pret√©rito perfeito simples
- N√£o uses emojis ou formata√ß√£o especial

Estrutura a resposta exatamente assim:

Momentos Fortes do Comercial:
- In√≠cio: [texto]
- Meio: [texto]  
- Fim: [texto]

Momentos Fracos do Comercial:
- In√≠cio: [texto]
- Meio: [texto]
- Fim: [texto]`

    const callSummaryResult = await analyzeInChunks(
      transcription,
      callSummaryPrompt,
      '√âs um analista especializado em resumos de chamadas de vendas.',
      'call summary analysis'
    )

    // Step 8: General Tips Analysis (Dicas Gerais)
    console.log('üß† Step 8: Analyzing general tips...')
    const tipsPrompt = `Analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e fornece dicas gerais para melhorar o desempenho do vendedor.

IMPORTANTE: Primeiro identifica quem √© o vendedor na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do vendedor identificado.

TRANSCRI√á√ÉO:
${transcription}

Fornece dicas gerais que nem s√£o pontos FORTES nem pontos FRACOS, mas que poderiam melhorar a performance geral de reuni√µes futuras.

Foca em:
- T√©cnicas de comunica√ß√£o que poderiam ser melhoradas
- Estrat√©gias de escuta ativa
- Formas de aprofundar a descoberta de necessidades
- T√©cnicas de apresenta√ß√£o de valor
- Habilidades de gest√£o de obje√ß√µes
- Estrat√©gias de fechamento

Estrutura a resposta como uma lista de dicas pr√°ticas e acion√°veis.
Seja espec√≠fico e objetivo.
Usa portugu√™s de Portugal (Lisboa).
Evita ger√∫ndios, usa pret√©rito perfeito simples.
N√£o uses emojis ou formata√ß√£o especial.`

    const tipsResult = await analyzeInChunks(
      transcription,
      tipsPrompt,
      '√âs um analista especializado em dicas de melhoria para vendas.',
      'tips analysis'
    )

    // Step 9: Focus for Next Calls Analysis (Foco para pr√≥ximas calls)
    console.log('üöÄ Step 9: Analyzing focus for next calls...')
    const focusPrompt = `Analisa a seguinte transcri√ß√£o de uma reuni√£o de vendas e identifica o foco espec√≠fico para pr√≥ximas calls.

IMPORTANTE: Primeiro identifica quem √© o vendedor na transcri√ß√£o. Procura por:
- Quem faz perguntas sobre necessidades, problemas, or√ßamento
- Quem apresenta solu√ß√µes, produtos ou servi√ßos  
- Quem conduz a reuni√£o
- Quem fala sobre pre√ßos, propostas, ou pr√≥ximos passos

Depois analisa APENAS o desempenho do vendedor identificado.

TRANSCRI√á√ÉO:
${transcription}

Identifica o foco espec√≠fico para pr√≥ximas calls, explicando concretamente como ultrapassar os obst√°culos encontrados e melhorar as falhas delineadas, ao mesmo tempo que partilhando as ferramentas a serem utilizadas para ajudar todo o processo.

Foca em:
- √Åreas espec√≠ficas que precisam de melhoria
- T√©cnicas ou estrat√©gias a implementar
- Ferramentas ou recursos a utilizar
- Objetivos espec√≠ficos para a pr√≥xima call
- M√©tricas ou indicadores a monitorizar

Estrutura a resposta como um plano de a√ß√£o claro e espec√≠fico.
Seja pr√°tico e acion√°vel.
Usa portugu√™s de Portugal (Lisboa).
Evita ger√∫ndios, usa pret√©rito perfeito simples.
N√£o uses emojis ou formata√ß√£o especial.`

    const focusResult = await analyzeInChunks(
      transcription,
      focusPrompt,
      '√âs um analista especializado em planos de a√ß√£o para vendas.',
      'focus analysis'
    )

    // Helper function to make GPT calls
    async function makeGPTCall(prompt: string, systemMessage: string) {
      // Estimate total tokens for this request
      const systemTokens = estimateTokens(systemMessage)
      const promptTokens = estimateTokens(prompt)
      const totalTokens = systemTokens + promptTokens
      
      console.log(`üî¢ Token estimation: System=${systemTokens}, Prompt=${promptTokens}, Total=${totalTokens}`)
      
      // Ensure we stay well under the 128K limit (using 100K as safety margin)
      if (totalTokens > 100000) {
        throw new Error(`Token count too high: ${totalTokens} tokens. Maximum allowed: 100000 tokens.`)
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: systemMessage
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.3,
          max_tokens: 1500
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`GPT call failed: ${response.statusText} - ${errorText}`)
      }

      const result = await response.json()
      return result.choices[0].message.content
    }

    // Combine all results into a comprehensive analysis
    console.log('üîó Combining analysis results...')
    
    let combinedAnalysis: any = {
      callType: callTypeResult.trim(),
      quantitativeAnalysis: quantitativeResult,
      strengths: [],
      weaknesses: [],
      scoring: {},
      strongMoments: {},
      weakMoments: {},
      callSummary: {},
      tips: '',
      focus: ''
    }

    // Parse JSON results
    try {
      const strengthsParsed = JSON.parse(strengthsResult)
      combinedAnalysis.strengths = Array.isArray(strengthsParsed) ? strengthsParsed : [strengthsParsed]
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not parse strengths as JSON:', strengthsResult)
      combinedAnalysis.strengths = [{ description: strengthsResult }]
    }

    try {
      const weaknessesParsed = JSON.parse(weaknessesResult)
      combinedAnalysis.weaknesses = Array.isArray(weaknessesParsed) ? weaknessesParsed : [weaknessesParsed]
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not parse weaknesses as JSON:', weaknessesResult)
      combinedAnalysis.weaknesses = [{ description: weaknessesResult }]
    }

    try {
      const scoringParsed = JSON.parse(scoringResult)
      combinedAnalysis.scoring = scoringParsed
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not parse scoring as JSON, parsing as text:', scoringResult)
      // Parse the text format scoring result
      const scoringLines = scoringResult.split('\n').filter(line => line.trim())
      const scoringObj: any = { raw: scoringResult }
      
      scoringLines.forEach(line => {
        const match = line.match(/^(.+?):\s*(\d+)\/5$/)
        if (match) {
          const key = match[1].trim().toLowerCase()
            .replace(/\s+/g, '')
            .replace(/[√ß√£√µ]/g, (char) => {
              if (char === '√ß') return 'c'
              if (char === '√£') return 'a'
              if (char === '√µ') return 'o'
              return char
            })
          const score = parseInt(match[2])
          scoringObj[key] = score
        }
      })
      
      combinedAnalysis.scoring = scoringObj
    }

    try {
      const momentsParsed = JSON.parse(momentsResult)
      combinedAnalysis.strongMoments = momentsParsed.strongMoments || momentsParsed
      combinedAnalysis.weakMoments = momentsParsed.weakMoments || momentsParsed
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not parse moments as JSON:', momentsResult)
      combinedAnalysis.strongMoments = { raw: momentsResult }
      combinedAnalysis.weakMoments = { raw: momentsResult }
    }

    try {
      const callSummaryParsed = JSON.parse(callSummaryResult)
      combinedAnalysis.callSummary = callSummaryParsed
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not parse call summary as JSON:', callSummaryResult)
      combinedAnalysis.callSummary = { raw: callSummaryResult }
    }

    // Add tips and focus results
    combinedAnalysis.tips = tipsResult
    combinedAnalysis.focus = focusResult

    console.log('‚úÖ Multi-step analysis completed successfully')
    console.log('üìä Combined analysis structure:', Object.keys(combinedAnalysis))
    console.log('üìù Scoring analysis preview:')
    console.log('--- START OF SCORING ---')
    console.log(combinedAnalysis.scoring?.raw || combinedAnalysis.scoring)
    console.log('--- END OF SCORING ---')
    console.log('üìù Full analysis preview:')
    console.log('--- START OF ANALYSIS ---')
    console.log(JSON.stringify(combinedAnalysis, null, 2))
    console.log('--- END OF ANALYSIS ---')

                   // Save analysis to Supabase if userId is provided
      let analysisId = null
      if (userId) {
        try {
         console.log('üíæ Saving analysis to Supabase...')
         
         // Extract score from scoring analysis
         let score = 0
         try {
           const scoringText = combinedAnalysis.scoring.raw || combinedAnalysis.scoring || ''
           console.log('üîç Extracting score from:', scoringText.substring(0, 200) + '...')
           
           // Try multiple patterns to extract the score
           const patterns = [
             /Pontua√ß√£o Total:\s*(\d+)\/40/i,
             /Pontua√ß√£o Total:\s*(\d+)/i,
             /Total:\s*(\d+)\/40/i,
             /Score:\s*(\d+)\/40/i,
             /Score:\s*(\d+)/i,
             /(\d+)\/40\s*\(Total\)/i,
             /Total Score:\s*(\d+)/i,
             /(\d+)\s*\/\s*40/i
           ]
           
           for (const pattern of patterns) {
             const scoreMatch = scoringText.match(pattern)
             if (scoreMatch) {
               score = parseFloat(scoreMatch[1])
               console.log('‚úÖ Score extracted with pattern:', pattern, 'Score:', score)
               break
             }
           }
           
           // If no pattern matched, try to find any number followed by /40
           if (score === 0) {
             const fallbackMatch = scoringText.match(/(\d+)\/40/)
             if (fallbackMatch) {
               score = parseFloat(fallbackMatch[1])
               console.log('‚úÖ Score extracted with fallback pattern. Score:', score)
             }
           }
           
           // If still no score found, try to find any number that could be a score
           if (score === 0) {
             const numbers = scoringText.match(/\b(\d{1,2})\b/g)
             if (numbers) {
               const possibleScores = numbers.map((n: string) => parseInt(n)).filter((n: number) => n >= 0 && n <= 40)
               if (possibleScores.length > 0) {
                 // Take the highest number that could be a score
                 score = Math.max(...possibleScores)
                 console.log('‚úÖ Score extracted from possible scores:', possibleScores, 'Selected:', score)
               }
             }
           }
           
         } catch (error) {
           console.warn('‚ö†Ô∏è Could not extract score from analysis:', error)
         }
         
         // Ensure score is a valid number and within range
         if (isNaN(score) || score < 0 || score > 40) {
           console.warn('‚ö†Ô∏è Invalid score detected, setting to 0:', score)
           score = 0
         }
         
                   console.log('üìä Final score value:', score, 'Type:', typeof score)

          // Validate user exists in profiles
         console.log('üîç Validating user...')
         
         const { data: user, error: userError } = await supabase
           .from('profiles')
           .select('id')
           .eq('id', userId)
           .single()
         
         if (userError || !user) {
           console.error('‚ùå User not found in profiles:', userId)
           throw new Error(`User with ID ${userId} not found in profiles`)
         }
         
         console.log('‚úÖ User validation passed')

                   // Validate and normalize call_type
          let normalizedCallType = 'Discovery Call' // Default to Discovery Call
          if (combinedAnalysis.callType) {
            const callTypeText = combinedAnalysis.callType.trim()
            // Check for exact matches first
            if (['Discovery Call', 'Follow-up Call', 'Q&A Call'].includes(callTypeText)) {
              normalizedCallType = callTypeText
            } else {
              // Try to extract call type from the text
              const lowerCallType = callTypeText.toLowerCase()
              if (lowerCallType.includes('discovery')) {
                normalizedCallType = 'Discovery Call'
              } else if (lowerCallType.includes('follow') || lowerCallType.includes('follow-up')) {
                normalizedCallType = 'Follow-up Call'
              } else if (lowerCallType.includes('q&a') || lowerCallType.includes('qa')) {
                normalizedCallType = 'Q&A Call'
              }
            }
          }
          
                    console.log('üìù Original call type:', combinedAnalysis.callType)
          console.log('üìù Normalized call type:', normalizedCallType)

          // Create feedback summary
          const feedbackSummary = `${combinedAnalysis.strengths?.length ? 'Strengths identified. ' : ''}${combinedAnalysis.weaknesses?.length ? 'Areas for improvement noted. ' : ''}Call type: ${normalizedCallType}`

          // Prepare the data to be inserted
         const insertData: any = {
           user_id: userId,
           status: 'completed',
           call_type: normalizedCallType,
           feedback: feedbackSummary,
           score: score,
           title: originalFileName ? originalFileName.replace(/\.[^/.]+$/, '').trim() : `An√°lise ${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`, // Store original file name without extension
           analysis: combinedAnalysis,
           analysis_metadata: {
             transcription_length: transcription.length,
             processing_time: new Date().toISOString(),
             analysis_steps: 6,
             was_truncated: false,
             analysis_method: 'chunked_full_context',
             original_sales_call_id: salesCallId || null, // Store original ID if provided
             original_file_name: originalFileName || null // Store original filename for display
           },
           transcription: transcription,
           custom_prompts: [
             'Call Type Classification',
             'Quantitative Analysis', 
             'Strong Points Analysis',
             'Weak Points Analysis',
             'Scoring Analysis',
             'Moments by Phase Analysis'
           ]
         }

         console.log('üíæ Attempting to save analysis to Supabase...')
         console.log('üìä Insert data structure:', Object.keys(insertData))
         console.log('üë§ User ID:', userId)
         console.log('üìù Call Type:', combinedAnalysis.callType)
         console.log('üìä Score:', score)
         console.log('üìè Transcription length:', transcription.length)
         console.log('üìÅ Original filename:', originalFileName)
         console.log('üìù Title being saved:', insertData.title)
         console.log('üìù Title type:', typeof insertData.title)
         console.log('üìù Title length:', insertData.title?.length)

         // Check if data is too large for Supabase
         const dataSize = JSON.stringify(insertData).length
         console.log('üìä Total data size:', dataSize, 'characters')
         
         if (dataSize > 1000000) { // 1MB limit
           console.warn('‚ö†Ô∏è Data size exceeds 1MB, truncating transcription...')
           insertData.transcription = insertData.transcription.substring(0, 500000) // Keep first 500K chars
           console.log('üìè Truncated transcription length:', insertData.transcription.length)
         }

         const { data, error } = await supabase
           .from('sales_call_analyses')
           .insert(insertData)
           .select()
           .single()

         if (error) {
           console.error('‚ùå Error saving to Supabase:', error)
           console.error('üîç Error details:', {
             code: error.code,
             message: error.message,
             details: error.details,
             hint: error.hint
           })
           console.error('üìä Data that failed to insert:', JSON.stringify(insertData, null, 2))
           
           // Log the raw error response for debugging
           console.error('üîç Raw error object:', JSON.stringify(error, null, 2))
           
           // Check for specific error types
           if (error.code === '23505') {
             console.error('‚ùå Duplicate key violation detected')
           } else if (error.code === '23503') {
             console.error('‚ùå Foreign key violation detected')
           } else if (error.code === '23502') {
             console.error('‚ùå Not null violation detected')
           } else if (error.code === '22P02') {
             console.error('‚ùå Invalid text representation detected')
           }
           
           throw new Error(`Failed to save analysis: ${error.message} (Code: ${error.code})`)
         }

         analysisId = data.id
         console.log('‚úÖ Analysis saved to Supabase with ID:', analysisId)
         console.log('üìù Saved title:', data.title)
         console.log('üìù Saved data:', JSON.stringify(data, null, 2))
         
       } catch (error) {
         console.error('‚ùå Error saving analysis to Supabase:', error)
         // Continue with the response even if Supabase save fails
       }
     }

    return NextResponse.json({
      success: true,
      analysis: combinedAnalysis,
      analysisId: analysisId,
      message: 'Multi-step analysis completed successfully',
      transcriptionLength: transcription.length,
      processedLength: transcription.length,
      wasTruncated: false,
      analysisMethod: 'chunked_full_context'
    })

  } catch (error) {
    console.error('üí• Analysis API error:', error)
    return NextResponse.json(
      { error: `Internal server error: ${error}` },
      { status: 500 }
    )
  }
}
